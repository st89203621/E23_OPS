#!/bin/bash

# 配置区（根据实际需求修改）
SEARCH_DIRS=("/data1/semptian/service")  # 要搜索的目录
TARGET_FILES=("bootstrap.yml" "application.yml""application.properties"  "application-test.yml" )  # 目标文件名
IP_REPLACEMENTS=(
    "192.168.13.1=192.168.28.1"
	"192.168.13.2=192.168.28.2"
	"192.168.13.3=192.168.28.3"
	"192.168.13.4=192.168.28.4"
	"192.168.13.5=192.168.28.5"
	"192.168.13.7=192.168.28.6"
	"192.168.13.8=192.168.28.7"
	"192.168.13.9=192.168.28.8"
	"192.168.13.10=192.168.28.9"
	"192.168.13.11=192.168.28.10"
	"192.168.13.12=192.168.28.11"
	"192.168.13.13=192.168.28.12"
	"192.168.13.14=192.168.28.13"
	"192.168.13.15=192.168.28.14"
	"192.168.13.16=192.168.28.15"
	"192.168.13.17=192.168.28.16"
	"192.168.13.30=192.168.28.17"
	"192.168.13.31=192.168.28.18"
	"192.168.13.78=192.168.28.19"
	"192.168.13.79=192.168.28.20"
	"192.168.15.51=192.168.28.101"
	"192.168.15.52=192.168.28.102"
	"192.168.15.53=192.168.28.103"
	"192.168.15.54=192.168.28.104"
	"192.168.15.55=192.168.28.105"
	"192.168.15.56=192.168.28.106"
	"192.168.15.57=192.168.28.107"
	"192.168.15.58=192.168.28.108"
	"192.168.15.59=192.168.28.109"
	"192.168.15.60=192.168.28.110"
	"192.168.15.61=192.168.28.111"
	"192.168.15.62=192.168.28.112"
	"192.168.15.63=192.168.28.113"
	"192.168.15.64=192.168.28.114"
	"192.168.15.65=192.168.28.115"
	"192.168.15.66=192.168.28.116"
	"192.168.15.67=192.168.28.117"
	"192.168.15.68=192.168.28.118"
	"192.168.15.69=192.168.28.119"
	"192.168.15.70=192.168.28.120"
	"192.168.15.71=192.168.28.121"
	"192.168.15.72=192.168.28.122"
	"192.168.15.73=192.168.28.123"
	"192.168.15.74=192.168.28.124"
	"192.168.15.75=192.168.28.125"
	"192.168.15.76=192.168.28.126"
	"192.168.15.77=192.168.28.127"
	"192.168.15.78=192.168.28.128"
	"192.168.15.79=192.168.28.129"
	"192.168.15.80=192.168.28.130"
	"192.168.15.81=192.168.28.131"
	"192.168.15.82=192.168.28.132"
	"192.168.15.83=192.168.28.133"
)

# 创建备份函数
backup_file() {
    local file=$1
    local backup_count=1
    while [[ -f "${file}.bak${backup_count}" ]]; do
        ((backup_count++))
    done
    cp -p "$file" "${file}.bak${backup_count}"
    echo "已创建备份: ${file}.bak${backup_count}"
}

# 替换IP函数
replace_ips() {
    local file=$1
    local modified=0

    for replacement in "${IP_REPLACEMENTS[@]}"; do
        old_ip="${replacement%=*}"
        new_ip="${replacement#*=}"

        # 使用 grep 检查是否包含该 IP（宽松匹配）
        if grep -Fq "$old_ip" "$file"; then
            echo "发现旧IP: $file -> $old_ip"

            # 创建备份（首次修改时）
            if [[ $modified -eq 0 ]]; then
                backup_file "$file"
            fi

            # 使用 sed 替换完整 IP（加单词边界 \b，并确保 sed -i 兼容）
            # 注意：在 sed 中 \b 是 backspace，要用 \\b 表示单词边界
            if sed -i'' -E "s/\\b${old_ip}\\b/${new_ip}/g" "$file"; then
                echo "  ✓ 替换成功: ${old_ip} → ${new_ip}"
                modified=1
            else
                echo "  ✗ 替换失败: sed 执行出错"
            fi
        fi
    done

    return $modified
}

# 主执行逻辑
main() {
    echo "===== 开始IP替换作业 ====="
    echo "配置:"
    echo "  搜索目录: ${SEARCH_DIRS[*]}"
    echo "  目标文件: ${TARGET_FILES[*]}"
    echo "  IP替换表:"
    printf '    %s\n' "${IP_REPLACEMENTS[@]}"
    echo "========================="

    total_modified=0
    
    # 递归查找并处理文件
    for dir in "${SEARCH_DIRS[@]}"; do
        [[ -d "$dir" ]] || continue
        
        for file_pattern in "${TARGET_FILES[@]}"; do
            while IFS= read -r -d '' file; do
                if replace_ips "$file"; then
                    ((total_modified++))
                fi
            done < <(find "$dir" -type f -name "$file_pattern" -print0)
            #done < <(find "$dir" -type f -print0)
        done
    done

    echo "===== 作业完成 ====="
    echo "共修改了 $total_modified 个文件"
    echo "详细修改记录保存在当前目录的 replacement.log"
}

# 记录日志并执行
main 2>&1 | tee -a "replacement_$(date +%Y%m%d_%H%M%S).log"